import { NextRequest, NextResponse } from 'next/server'
import { validateRequest, createSuccessResponse, createErrorResponse } from '@/lib/validation/api-validators'
import { withErrorHandler } from '@/lib/errors/api-error-handler'
import { createGeneralRateLimit } from '@/lib/security/rate-limiter'
import { logger } from '@/lib/logging/api-logger'
import { prisma } from '@/lib/database/prisma'
import bcrypt from 'bcryptjs'

export const POST = withErrorHandler(async(request: NextRequest) {
  try {
    const startTime = Date.now()
    const requestId = Math.random().toString(36).substring(7)

    // Log da request
    logger.logRequest(request, requestId)
    // Aplicar rate limiting
    const rateLimit = createGeneralRateLimit()
    rateLimit(request)
    // Obter userId da sessão atual para otimizar a busca
    let userId: string | null = null
    const sessionCookie = request.cookies.get('session')?.value

    if (sessionCookie) {
      try {
    const startTime = Date.now()
    const requestId = Math.random().toString(36).substring(7)

    // Log da request
    logger.logRequest(request, requestId)
    // Aplicar rate limiting
    const rateLimit = createGeneralRateLimit()
    rateLimit(request)
        const { verifyAccessToken } = await import('@/lib/auth/jwt')
        const payload = await verifyAccessToken(sessionCookie)
        userId = String(payload.sub || '')
      } catch {
        // Fallback para cookie legado
        try {
    const startTime = Date.now()
    const requestId = Math.random().toString(36).substring(7)

    // Log da request
    logger.logRequest(request, requestId)
    // Aplicar rate limiting
    const rateLimit = createGeneralRateLimit()
    rateLimit(request)
          const legacy = JSON.parse(sessionCookie)
          userId = legacy?.userId || null
        } catch {}
      }
    }

    // Revogar refresh token se existir (otimizado com userId)
    const refresh = request.cookies.get('refresh_token')?.value
    if (refresh && userId) {
      // Buscar apenas tokens do usuário atual
      const userTokens = await prisma.refreshToken.findMany({
        where: {
          userId: userId,
          revokedAt: null
        }
      })

      // Processar em paralelo para melhor performance
      const revokePromises = userTokens.map(async (t) => {
        if (await bcrypt.compare(refresh, t.tokenHash)) {
          return prisma.refreshToken.update({
            where: { id: t.id },
            data: { revokedAt: new Date() }
          })
        }
        return null
      })

      await Promise.all(revokePromises)
    }

    const response = NextResponse.json({
      success: true,
      message: 'Logout realizado com sucesso'
    })

    // Limpar cookies de sessão e refresh
    response.cookies.set('session', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    })
    response.cookies.set('refresh_token', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    })

    return response

  } catch (error) {
    console.error('Erro no logout:', error)
    return NextResponse.json(
      { success: false, error: 'Erro interno do servidor' },
      { status: 500 }
    )
  }
}
