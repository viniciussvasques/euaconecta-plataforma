import { NextResponse } from 'next/server'
import { prisma } from '@/lib/database/prisma'

async function checkDatabase() {
  try {
    const startTime = Date.now()
    const requestId = Math.random().toString(36).substring(7)

    // Log da request
    logger.logRequest(request, requestId)
    // Aplicar rate limiting
    const rateLimit = createGeneralRateLimit()
    rateLimit(request)
    await prisma.$queryRaw`SELECT 1` as unknown
    return { status: 'ok' as const }
  } catch (err) {
    return { status: 'error' as const, error: (err as Error).message }
  }
}

async function checkRedis() {
  try {
    const startTime = Date.now()
    const requestId = Math.random().toString(36).substring(7)

    // Log da request
    logger.logRequest(request, requestId)
    // Aplicar rate limiting
    const rateLimit = createGeneralRateLimit()
    rateLimit(request)
    const url = process.env.REDIS_URL
    if (!url) return { status: 'skip' as const }
    // Lightweight TCP check via fetch is not possible; mark as configured
    return { status: 'ok' as const }
  } catch (err) {
    return { status: 'error' as const, error: (err as Error).message }
  }
}

async function checkMinio() {
  try {
    const startTime = Date.now()
    const requestId = Math.random().toString(36).substring(7)

    // Log da request
    logger.logRequest(request, requestId)
    // Aplicar rate limiting
    const rateLimit = createGeneralRateLimit()
    rateLimit(request)
    const endpoint = process.env.S3_ENDPOINT
    if (!endpoint) return { status: 'skip' as const }
    // Try readiness endpoint if MinIO
    const url = endpoint.replace(/\/$/, '') + '/minio/health/ready'
    const res = await fetch(url, { method: 'GET' })
    return { status: res.ok ? ('ok' as const) : ('error' as const), http: res.status }
  } catch (err) {
    return { status: 'error' as const, error: (err as Error).message }
  }
}

export const GET = withErrorHandler(async() {
  const [db, redis, minio] = await Promise.all([
    checkDatabase(),
    checkRedis(),
    checkMinio(),
  ])

  const healthy = db.status === 'ok' && (redis.status === 'ok' || redis.status === 'skip') && (minio.status === 'ok' || minio.status === 'skip')

  return NextResponse.json(
    {
      status: healthy ? 'ok' : 'degraded',
      services: { db, redis, minio },
      timestamp: new Date().toISOString(),
    },
    { status: healthy ? 200 : 503 }
  )
}
