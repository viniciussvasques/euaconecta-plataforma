import { NextRequest, NextResponse } from 'next/server'
import { validateRequest, createSuccessResponse, createErrorResponse } from '@/lib/validation/api-validators'
import { withErrorHandler } from '@/lib/errors/api-error-handler'
import { createGeneralRateLimit } from '@/lib/security/rate-limiter'
import { logger } from '@/lib/logging/api-logger'
import { prisma } from '@/lib/database/prisma'

export const GET = withErrorHandler(async(request: NextRequest) {
  try {
    const startTime = Date.now()
    const requestId = Math.random().toString(36).substring(7)

    // Log da request
    logger.logRequest(request, requestId)
    // Aplicar rate limiting
    const rateLimit = createGeneralRateLimit()
    rateLimit(request)
    const { searchParams } = new URL(request.url)
    const startDate = searchParams.get('startDate')
    const endDate = searchParams.get('endDate')

    if (!startDate || !endDate) {
      return NextResponse.json(
        { success: false, error: 'Data inicial e final são obrigatórias' },
        { status: 400 }
      )
    }

    const start = new Date(startDate)
    const end = new Date(endDate)
    end.setHours(23, 59, 59, 999)

    // Total counts
    const totalUsers = await prisma.user.count({
      where: {
        createdAt: {
          gte: start,
          lte: end
        }
      }
    })

    const totalPackages = await prisma.package.count({
      where: {
        createdAt: {
          gte: start,
          lte: end
        }
      }
    })

    const totalConsolidations = await prisma.consolidationGroup.count({
      where: {
        createdAt: {
          gte: start,
          lte: end
        }
      }
    })

    const totalRevenue = await prisma.payment.aggregate({
      where: {
        status: 'succeeded',
        createdAt: {
          gte: start,
          lte: end
        }
      },
      _sum: {
        amountCents: true
      }
    })

    // Monthly stats
    const monthlyStats = await prisma.$queryRaw`
      SELECT 
        TO_CHAR(created_at, 'YYYY-MM') as month,
        COUNT(DISTINCT CASE WHEN table_name = 'User' THEN id END) as users,
        COUNT(DISTINCT CASE WHEN table_name = 'Package' THEN id END) as packages,
        COUNT(DISTINCT CASE WHEN table_name = 'ConsolidationGroup' THEN id END) as consolidations,
        COALESCE(SUM(CASE WHEN table_name = 'Payment' AND status = 'succeeded' THEN amount_cents END), 0) as revenue
      FROM (
        SELECT 'User' as table_name, id, created_at FROM users WHERE created_at >= ${start} AND created_at <= ${end}
        UNION ALL
        SELECT 'Package' as table_name, id, created_at FROM packages WHERE created_at >= ${start} AND created_at <= ${end}
        UNION ALL
        SELECT 'ConsolidationGroup' as table_name, id, created_at FROM consolidation_groups WHERE created_at >= ${start} AND created_at <= ${end}
        UNION ALL
        SELECT 'Payment' as table_name, id, created_at, amount_cents, status FROM payments WHERE created_at >= ${start} AND created_at <= ${end}
      ) combined
      GROUP BY TO_CHAR(created_at, 'YYYY-MM')
      ORDER BY month
    `

    // Top users
    const topUsers = await prisma.user.findMany({
      where: {
        packages: {
          some: {
            createdAt: {
              gte: start,
              lte: end
            }
          }
        }
      },
      include: {
        packages: {
          where: {
            createdAt: {
              gte: start,
              lte: end
            }
          }
        },
        payments: {
          where: {
            status: 'succeeded',
            createdAt: {
              gte: start,
              lte: end
            }
          }
        }
      },
      orderBy: {
        packages: {
          _count: 'desc'
        }
      },
      take: 10
    })

    const topUsersFormatted = topUsers.map(user => ({
      id: user.id,
      name: user.name || 'Usuário sem nome',
      email: user.email,
      packageCount: user.packages.length,
      totalSpent: user.payments.reduce((sum, payment) => sum + (payment.amountCents || 0), 0) / 100
    }))

    // Consolidation status stats
    const consolidationStats = await prisma.consolidationGroup.groupBy({
      by: ['status'],
      where: {
        createdAt: {
          gte: start,
          lte: end
        }
      },
      _count: {
        id: true
      }
    })

    // Package status stats
    const packageStats = await prisma.package.groupBy({
      by: ['status'],
      where: {
        createdAt: {
          gte: start,
          lte: end
        }
      },
      _count: {
        id: true
      }
    })

    const reportData = {
      totalUsers,
      totalPackages,
      totalConsolidations,
      totalRevenue: (totalRevenue._sum.amountCents || 0) / 100,
      monthlyStats: (monthlyStats as Array<{ month: string; users: string; packages: string; consolidations: string; revenue: string }>).map(stat => ({
        month: stat.month,
        users: parseInt(stat.users) || 0,
        packages: parseInt(stat.packages) || 0,
        consolidations: parseInt(stat.consolidations) || 0,
        revenue: parseFloat(stat.revenue) / 100 || 0
      })),
      topUsers: topUsersFormatted,
      consolidationStats: consolidationStats.map(stat => ({
        status: stat.status,
        count: stat._count.id
      })),
      packageStats: packageStats.map(stat => ({
        status: stat.status,
        count: stat._count.id
      }))
    }

    return NextResponse.json({
      success: true,
      data: reportData
    })

  } catch (error) {
    console.error('Erro ao gerar relatório:', error)
    return NextResponse.json(
      { success: false, error: 'Erro interno do servidor' },
      { status: 500 }
    )
  }
}
